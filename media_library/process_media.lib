#!/usr/bin/env bash

# utilities re-used by the media processing tools
UTIL_DIR=${UTIL_DIR:-~/.media_processing}
mkdir -p "$UTIL_DIR"
MEDIA_DB="${MEDIA_DB:-${UTIL_DIR}/media.sqlite}"
# Database output delimiter (CSV format to avoid collision with | in tag names)
DB_DELIMITER=','

log_notice(){
  echo "$1"  >&2
}
log_debug(){
  printf "\033[93m$1\033[0m\n"  >&2
}
log_info(){
  # ligh blue
  printf "\033[94m$1\033[0m\n"  >&2
}
log_error(){
  printf "\033[31m$1\033[0m\n" >&2
}
log_success(){
  printf "\033[32m$1\033[0m\n" >&2
}

create_database(){

  echo ".open $MEDIA_DB" | sqlite3
  log_notice "Initializing database $MEDIA_DB"

  # Create all tables at once with foreign key constraints
  # name is the primary key and used for all foreign key relationships
  # long_name is a cosmetic/convenience field for display and hierarchy definition
  SQL="PRAGMA foreign_keys = ON;
  CREATE TABLE tag_types (type TEXT PRIMARY KEY);
  CREATE TABLE tags (
    name TEXT PRIMARY KEY,
    long_name TEXT UNIQUE,
    type TEXT,
    parent TEXT,
    FOREIGN KEY (type) REFERENCES tag_types(type),
    FOREIGN KEY (parent) REFERENCES tags(name));
  CREATE TABLE synonyms (synonym TEXT PRIMARY KEY, canonic TEXT,
    FOREIGN KEY (canonic) REFERENCES tags(name));"
  sql_safe "$SQL"
  log_notice "Created tables in database $MEDIA_DB"

  # Insert initial data
  SQL="
  INSERT INTO tag_types (type) VALUES ('container');
  INSERT INTO tag_types (type) VALUES ('leaf');
  "
  sql_safe "$SQL" &&  log_notice "Database $MEDIA_DB is ready"
}

dump_db() {
  tables=( $(echo ".tables" | sqlite3 "$MEDIA_DB" ) )
  for table in "${tables[@]}"; do
    echo -e "\nTable: $table"
    SQL="SELECT * FROM $table;"
    echo "$SQL" | sqlite3 -column -header  "$MEDIA_DB"
  done
}

drop_database(){
  rm "$MEDIA_DB"
  log_notice "Dropped database $MEDIA_DB"
}

# Optionally use an in memory version of sqlite for faster access
# Requires SQLITE_USE_TMPFS environment variable to be set.
# Copies existing database to tmpfs on open.
# Serializes back to disk on exit.
open_database(){
  if [[ -n "$SQLITE_USE_TMPFS" ]]; then
    MEDIA_DB_FILE=$MEDIA_DB

    # Detect OS and use appropriate tmpfs location
    if [[ "$(uname)" == "Darwin" ]]; then
      # macOS - /tmp is tmpfs
      TMPFS_DIR="/tmp/media_processing_$$"
    else
      # Linux - /dev/shm is tmpfs
      TMPFS_DIR="/dev/shm/media_processing_$$"
    fi

    mkdir -p "$TMPFS_DIR"
    MEDIA_DB="$TMPFS_DIR/media.sqlite"

    if [[ -f "$MEDIA_DB_FILE" ]]; then
      cp "$MEDIA_DB_FILE" "$MEDIA_DB"
      log_notice "Copied existing database to tmpfs for faster access"
    fi
    log_notice "Using tmpfs for database at $MEDIA_DB"
    trap "close_database" EXIT
  fi
}

close_database(){
  if [[ -n "$SQLITE_USE_TMPFS" ]]; then
    cp "$MEDIA_DB" "$MEDIA_DB_FILE"
    rm -rf "$(dirname "$MEDIA_DB")"
    log_notice "Serialized tmpfs database back to $MEDIA_DB_FILE"
  fi
}

# Fast SQL wrapper for reads - no retry logic
sql_fast() {
  echo "$1" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB"
}
sql_fast_timed() {
  local start=$(date +%s%N)
  local result=$(echo "$1" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")
  local end=$(date +%s%N)
  local elapsed=$(( (end - start) / 1000000 ))
  echo "[${elapsed}ms] $1" >&2
  echo "$result"
}

# Safe SQL wrapper for writes - retries on lock errors, logs all errors
sql_safe() {
  local sql="$1"
  local max_retries=5
  local retry=0
  local temp_err=$(mktemp)

  while [ $retry -lt $max_retries ]; do
    if echo "$sql" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB" 2>"$temp_err"; then
      rm -f "$temp_err"
      return 0
    fi

    if grep -q "database is locked" "$temp_err"; then
      retry=$((retry + 1))
      log_info "SQLite locked, retry $retry/$max_retries"
      sleep 0.$((RANDOM % 10))
      continue
    fi

    # Non-lock error
    local error_msg=$(cat "$temp_err")
    rm -f "$temp_err"
    log_error "SQL failed: $error_msg"
    log_error "SQL was: $sql"
    return 1
  done

  log_error "SQLite locked after $max_retries retries"
  log_error "SQL was: $sql"
  rm -f "$temp_err"
  return 1
}


# Will search for a tag by name, or synonym.
# returns a csv listing "name, long_name, type, parent"
# That has to be parsed by the caller.
get_tag_data(){
  tag_name=$1
  long_name=$tag_name
  tag_name=$(get_short_name "$tag_name")
  if [[ -n "$2" ]] ; then
    log_error "Unexpected argument '$2' . Quote tags when using get_tag.";
    exit 1;
  fi
  # Usually do a direct shortname match.
  # Fall back to synonym after that
  # If asked for long_name, return that first
  #SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$long_name';"
  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$long_name' OR tags.name='$tag_name';"
  result=$(sql_fast "$SQL")

  #if [ -z "$result" ]; then
  #  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE name='$tag_name';"
  #  result=$(sql_fast "$SQL")
  #fi

  # Join the tags to the synonyms table to find the result by synonym
  if [ -z "$result" ]; then
    # log_debug "Looking for synonyms of '$tag_name'"
    SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM synonyms INNER JOIN tags ON synonyms.canonic = tags.name WHERE synonyms.synonym='$tag_name';"
    result=$(sql_fast "$SQL")
    if [ -n "$result" ]; then
      log_info "Using synonym for '$tag_name' "
    fi
  fi
  if [ -z "$result" ]; then
    log_info "Could not find an entry or synonym matching $tag_name"
  fi

  echo $result;
}

# Load tag data into an associative array for convenient access
# Usage: get_tag_info "Dog"
#        echo "${tag_info[name]}"
#        echo "${tag_info[long_name]}"
#        echo "${tag_info[type]}"
#        echo "${tag_info[parent]}"
get_tag_info() {
  local tag="$1"
  local csv_data=$(get_tag_data "$tag")

  if [[ -z "$csv_data" ]]; then
    log_debug "No tag info found for '$tag'"
    return 1
  fi

  # Declare global associative array (bash 4+)
  declare -gA tag_info

  IFS="${DB_DELIMITER}" read -r tag_info[name] tag_info[long_name] tag_info[type] tag_info[parent] <<< "$csv_data"
}

# Individual accessor functions for single-value lookups
# Getting the name of a tag you already know seems redundant,
# but all the accessors include synonym and longname collapsing
get_tag_name() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r name _ _ _ <<< "$tag_data"
  echo "$name"
}

get_long_name(){
  tag_data=$(get_tag_data "$1");
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -z "$long_name" ]] ; then
    log_error "failed to find long name for $1"
  fi
  echo $long_name;
}

# This parses and trims a string, getting the short name from a long hierarchical name
# not a DB accessor like the rest.
get_short_name(){
  long_name="$1"
  local pipe_pattern='\|'
  # Get everything after the last pipe
  tag_name="${long_name##*|}"
  echo "$tag_name"
}

get_tag_type() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r _ _ type _ <<< "$tag_data"
  echo "$type"
}

# Helper function that sets global variables (alternative to Pattern 1)
# Usage: parse_tag_data "$(get_tag_data 'Dog')"
#        echo "$tag_name $long_name $type $parent"
# Note: Variables are GLOBAL (no local keyword) so available to caller
# Can also be used to unset these variables.
parse_tag_data() {
  local csv_data="$1"
  if [[ -z "$csv_data" ]]; then
    tag_name=""
    long_name=""
    type=""
    parent=""
    return 1
  fi
  # These variables are NOT local, so they're set in the caller's scope
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$csv_data"
}

# Check if a tag exists in the database, and create it if not
# usage: ensure_tag_exists tag_name [tag_type] [parent]
ensure_tag_exists(){
  local tag_name=$1
  local long_name=$tag_name
  local tag_type=${2:-leaf}  # Default to 'leaf' if no type is provided
  local parent=$3            # Optional parent tag

  if [[ -z "$tag_name" ]] ; then
    log_error "No tag name for $0"
    return 1
  fi

  # If it appears to be a '|' delimited heirarchical tagname, deal with that
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi

  # Check if the tag exists.
  tag_data=$(get_tag_data "$tag_name");

  # If the tag doesn't exist, create it
  if [ -z "$tag_data" ]; then
    log_notice "Tag '$tag_name' does not exist. Creating it with type '$tag_type'..."
    # create the entry, then add the parent association after
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO tags (name, long_name, type) VALUES ('$tag_name', '$long_name', '$tag_type');
    "
    sql_safe "$SQL"
  else
    log_debug "Tag '$tag_name' already exists."
  fi

  # If parent is provided and the tag exists but has no parent, update it.
  current_parent=$(get_parent "$tag_name");
  if [[ -n "$parent" && -z "$current_parent" ]]; then
    log_info "Tag '$tag_name' should have parent '$parent' . Ensuring parent exists first."
    ensure_tag_exists "$parent"
    # That process may have resolved a synonym, so re-resolve to get the canonic parent name
    parent=$(get_tag_name "$parent")
    log_info "Ensuring parentage of '$tag_name' is in place."
    set_parent "$tag_name" "$parent"
  fi
  # log_info "Tag '$tag_name' exists"
}

update_long_name_to_match_parent(){
  tag_name=$1
  parent=$(get_parent "$tag_name")
  parent_long_name=$(get_long_name "$parent")
  current_long_name=$(get_long_name "$tag_name")
  expected_long_name="${parent_long_name}|${tag_name}"
  if [[ "$current_long_name" != "$expected_long_name" ]] ; then
    log_notice "Updating long_name of '$tag_name' from '$current_long_name' to '$expected_long_name' ."
    SQL="
    PRAGMA foreign_keys = ON;
    UPDATE tags SET long_name = '$expected_long_name' WHERE name = '$tag_name';
    "
    sql_safe "$SQL"
  else
    log_debug "Long name of '$tag_name' is already correct: '$expected_long_name'."
  fi
}

# Lookup by name or longname. $tag may be any shape.
# It's valid for a tag to have no parent/
get_parent(){
  tag=$1
  tag_data=$(get_tag_data "$tag")
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -n "$parent" ]] ; then
    log_debug "Parent of '$tag_name' is '$parent' ."
  else
    log_debug "'$tag_name' has no parent in the DB yet."
  fi
  echo $parent;
}

# Set parent relationship using tag names as foreign keys
# Parameters can be name, long_name, or synonym - will be resolved to name
set_parent(){
  child_tag=$1
  parent_tag=$2
  log_notice "Setting parent of '$child_tag' to '$parent_tag'."

  # Resolve both to canonical names in case someone was using synonyms etc.
  parent_name=$(get_tag_name "$parent_tag")
  child_name=$(get_tag_name "$child_tag")

  if [[ -z "$child_name" ]]; then
    log_error "Cannot find name of tag tag '$child_tag'. The child tag must exist before it can have the parent set"
    return 1
  fi

  if [[ -z "$parent_name" ]]; then
    log_error "Cannot find name of parent tag '$parent_tag'. The parent tag must exist befor it is referenced."
    return 1
  fi

  SQL="
  PRAGMA foreign_keys = ON;
  UPDATE tags SET parent = '$parent_name' WHERE name = '$child_name';
  "
  sql_safe "$SQL"
  update_long_name_to_match_parent "$child_name"
}

# usage:
# set_synonym canonic synonym
# Resolves canonic to tag name for foreign key relationship
# TODO - cehck for duplicates, and re-parent any items currently using the synonym as parent
set_synonym(){
  canonic=$1
  synonym=$2

  # Resolve to canonical tag name
  canonic_name=$(get_tag_name "$canonic")
  if [[ -z "$canonic_name" ]]; then
    log_error "No tag found for '$canonic'"
    return 1
  fi

  # Ensure the canonic tag exists before setting the synonym
  ensure_tag_exists "$canonic"

  # Check if the synonym already exists
  SQL="SELECT synonym FROM synonyms WHERE synonym='$synonym';"
  result=$(sql_fast "$SQL")

  # If the synonym doesn't exist, create it
  if [ -z "$result" ]; then
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO synonyms (synonym, canonic) VALUES ('$synonym', '$canonic_name');
    ";
    sql_safe "$SQL"
    log_notice "Added synonym '$synonym' for tag '$canonic_name'."
  else
    log_debug "Synonym '$synonym' already exists."
  fi
}

# List all tags in a column
# If a tag has synonyms, list each of them, indented, after the tag.
# If a tag has a parent, it will be displayed under its parent with indentation.
dump_tags(){
  # First, get all root tags (tags with no parent)
  SQL="SELECT name, long_name FROM tags WHERE parent IS NULL OR parent = '' ORDER BY name;"
  root_tags=$(sql_fast "$SQL")

  # Process each root tag
  echo "$root_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name; do
    # Display the root tag
    if [ "$tag_type" = "container" ]; then
      printf "\033[90m%s\033[0m\n" "$tag_name [root]"
    else
      printf "%s\n" "$tag_name"
    fi

    # Display synonyms for this tag
    display_synonyms "$long_name" "  "

    # Display child tags recursively
    display_child_tags "$long_name" "|--"
  done
}


# Utility to check if the current scope has these variables set/
dump_tag_values(){
  echo "  name: $tag_name"
  echo "  long_name: $long_name"
  echo "  type: $type"
  echo "  parent: $parent"
}

# Update the tag hierarchy based on tag names with slashes.
# This is housekeeping, to deal with data thant may have been imported roughly
# Tags with delimiters in their names will have their parent set to the leftmost parts
# For example, "Location|Inside|Bedroom" will have a parent of "Location|Inside"
# The delimiter is conventiolnally "|" to conform with Adobe Bridge HeirarchicalSubject
# but may be expanded to "/" or ":" instead.
#
# This is unused, and may be deprecated - was just to clean bad old data.
update_tag_hierarchy(){
  log_notice "Updating tag hierarchy..."
  DELIMITER="|";

  # Get all tags with slashes in their names
  SQL="SELECT name FROM tags WHERE name LIKE '%${DELIMITER}%';"
  tags_with_slashes=$(sql_fast "$SQL")

  # Process each tag
  if [ -n "$tags_with_slashes" ]; then
    # First, ensure all parent tags exist
    echo "$tags_with_slashes" | while read -r tag_name; do
      parent=$(get_parent_name "$tag_name")
      if [ -n "$parent" ]; then
        ensure_tag_exists "$parent" "container"
      fi
      set_parent "$tag_name" "$parent"
    done
    log_notice "Tag hierarchy updated successfully."
  else
    log_notice "No tags with ${DELIMITER} delimiters found."
  fi

  # Display the updated hierarchy
  log_notice "Displaying updated tag hierarchy:"
  dump_tags
}

# Chop the rightmost part of a path off.
# Basically identical to dirname?
# inverse of get_shortname
get_parent_name() {
  long_name="$1"
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    #tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi
  return $parent;
}

# Helper function to display synonyms for a tag
display_synonyms(){
  local tag="$1"
  local indent="$2"

  # Resolve to canonical name (canonic column stores names)
  local tag_name=$(get_tag_name "$tag")
  if [[ -z "$tag_name" ]]; then
    return 0
  fi

  # Get all synonyms for this tag
  SQL="SELECT synonym FROM synonyms WHERE canonic='$tag_name' ORDER BY synonym;"
  synonyms=$(sql_fast "$SQL")

  # List each synonym indented
  if [ -n "$synonyms" ]; then
    echo "$synonyms" | while read -r synonym; do
      printf "${indent}AKA: %s\n" "$synonym"
    done
  fi
}

# Helper function to display child tags recursively
# Expects tag identifier (name, long_name, or synonym) - will be resolved to name
display_child_tags(){
  local parent_tag="$1"
  local indent="$2"

  # Resolve parent_tag to canonical name (parent column stores names)
  local parent_name=$(get_tag_name "$parent_tag")
  if [[ -z "$parent_name" ]]; then
    return 0
  fi

  # Get all child tags for this parent
  SQL="SELECT name, long_name, type FROM tags WHERE parent='$parent_name' ORDER BY name;"
  child_tags=$(sql_fast "$SQL")
  # Process each child tag
  if [ -n "$child_tags" ]; then
    echo "$child_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name tag_type; do
      # Display the child tag with indentation
      if [ "$tag_type" = "container" ]; then
        printf "${indent}\033[90m%s\033[0m\n" "$tag_name"
      else
        printf "${indent}%s\n" "$tag_name"
      fi

      # Display synonyms for this child tag
      display_synonyms "$long_name" "${indent}  "

      # Recursively display this child's children (pass name for FK lookup)
      display_child_tags "$tag_name" "${indent}${indent}"
    done
  fi
}

# Parallel file processing utility
# Processes all files recursively in the input arguments using parallel execution.
# Expects the caller to define a 'processFile' function and export any additional
# functions needed (e.g., export -f processWebpFile if processFile depends on it).
# Note: Feedback from sub-processes may get jumbled due to parallel execution.
# Note: Uses BSD xargs syntax (macOS) - -0: null-separated, -P: parallel, -I: replace
parallalProcessFiles() {
    export -f processFile;
    find "$@" -type f -print0 | xargs -0 -P 4 -I {} bash -c 'processFile "$1"' _ "{}"
}

# ensure
# Db file locations is accessible, has an sqlite db, has the expected schema, and is responding.
# Will try to create it if it's missing, or re-create it if it's corrupt.
# Returns 0 on success, 1 on failure.
# On failure, the caller may retry after a delay to handle transient locks.
verifyDatabase() {
  log_notice "MEDIA_DB=$MEDIA_DB"

  # Require sqlite3 or die
  if ! command -v sqlite3 >/dev/null 2>&1; then
    log_error "sqlite3 is required"
    exit 1
  fi

  # Check if the database file exists
  if [ ! -f "$MEDIA_DB" ]; then
    log_notice "Database file $MEDIA_DB does not exist. Creating it..."
    create_database
    return 0
  fi

  # Capture stderr to detect specific errors
  local error_output=$(mktemp)

  # Check if it's a valid SQLite database
  if ! echo "PRAGMA integrity_check;" | sqlite3 "$MEDIA_DB" > /dev/null 2>"$error_output"; then
    local error_msg=$(cat "$error_output")
    rm -f "$error_output"

    # Check for lock vs corruption
    if [[ "$error_msg" =~ "database is locked" ]]; then
      log_error "Database is locked by another process. Waiting..."
      sleep 1
      return 1
    elif [[ "$error_msg" =~ "not a database" ]] || [[ "$error_msg" =~ "malformed" ]]; then
      log_error "Database file $MEDIA_DB is corrupt. Recreating it..."
      drop_database
      create_database
    else
      log_error "Database error: $error_msg"
      return 1
    fi
  else
    rm -f "$error_output"

    # Verify expected tables exist
    local tables=$(echo ".tables" | sqlite3 "$MEDIA_DB" 2>/dev/null)
    if [[ ! "$tables" =~ "tags" ]] || [[ ! "$tables" =~ "synonyms" ]]; then
      log_error "Database missing required tables. Recreating..."
      drop_database
      create_database
    else
      log_notice "Database file $MEDIA_DB exists and is valid."
    fi
  fi
}

verifyDatabase
open_database