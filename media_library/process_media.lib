#!/usr/bin/env bash

# utilities re-used by the media processing tools
# Define MEDIA_DB path before initializing to override default location.

[[ $MEDIA_LIB_DIR ]] || MEDIA_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
[[ $SCRIPT_DIR ]] || SCRIPT_DIR="$(dirname "$MEDIA_LIB_DIR")"

# Source SQLite database management functions
source "${SCRIPT_DIR}/sqlite.lib"
source "${SCRIPT_DIR}/feedback.lib"

MEDIA_DATA_DIR=${MEDIA_DATA_DIR:-~/.media_processing}
mkdir -p "$MEDIA_DATA_DIR"
MEDIA_DB="${MEDIA_DB:-${MEDIA_DATA_DIR}/media.sqlite}"

# Check if a tag exists in the database, and create it if not
# usage: ensure_tag_exists tag_name [tag_type] [parent]
ensure_tag_exists(){
  local tag_name=$1
  local long_name=$tag_name
  local tag_type=${2:-leaf}  # Default to 'leaf' if no type is provided
  local parent=$3            # Optional parent tag

  if [[ -z "$tag_name" ]] ; then
    log_error "No tag name for $0"
    return 1
  fi

  # If it appears to be a '|' delimited heirarchical tagname, deal with that
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi

  # Check if the tag exists.
  tag_data=$(get_tag_data "$tag_name");

  # If the tag doesn't exist, create it
  if [ -z "$tag_data" ]; then
    log_notice "Tag '$tag_name' does not exist. Creating it with type '$tag_type'..."
    # create the entry, then add the parent association after
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO tags (name, long_name, type) VALUES ('$tag_name', '$long_name', '$tag_type');
    "
    sql_safe "$SQL"
  else
    log_debug "Tag '$tag_name' already exists."
  fi

  # If parent is provided and the tag exists but has no parent, update it.
  current_parent=$(get_parent "$tag_name");
  if [[ -n "$parent" && -z "$current_parent" ]]; then
    log_info "Tag '$tag_name' should have parent '$parent' . Ensuring parent exists first."
    ensure_tag_exists "$parent"
    # That process may have resolved a synonym, so re-resolve to get the canonic parent name
    parent=$(get_tag_name "$parent")
    log_info "Ensuring parentage of '$tag_name' is in place."
    set_parent "$tag_name" "$parent"
  fi
  # log_info "Tag '$tag_name' exists"
}

# Will search for a tag by name, or synonym.
# returns a csv listing "name, long_name, type, parent"
# That has to be parsed by the caller.
# The returned name may be different from the input if a synonym was used or capitalization was adjusted.
# caller should use the returned name from now on.
get_tag_data(){
  tag_name=$1
  long_name=$tag_name
  tag_name=$(get_short_name "$tag_name")
  if [[ -n "$2" ]] ; then
    log_error "Unexpected argument '$2' . Quote tags when using get_tag.";
    exit 1;
  fi
  # Usually do a direct shortname match.
  # Fall back to synonym after that
  # If asked for long_name, return that first
  #SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$long_name';"
  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE LOWER(tags.long_name)=LOWER('$long_name') OR LOWER(tags.name)=LOWER('$tag_name');"
  result=$(sql_fast "$SQL")

  #if [ -z "$result" ]; then
  #  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE name='$tag_name';"
  #  result=$(sql_fast "$SQL")
  #fi

  # Join the tags to the synonyms table to find the result by synonym
  if [ -z "$result" ]; then
    # log_debug "Looking for synonyms of '$tag_name'"
    SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM synonyms INNER JOIN tags ON LOWER(synonyms.canonic) = LOWER(tags.name) WHERE LOWER(synonyms.synonym)=LOWER('$tag_name');"
    result=$(sql_fast "$SQL")
    if [ -n "$result" ]; then
      log_info "Using '$tag_name' as a synonym for the canonic '${result%%,*}' ."
    fi
  fi
  if [ -z "$result" ]; then
    log_info "Could not find an entry or synonym matching $tag_name"
  fi

  echo $result;
}

# Load tag data into an associative array for convenient access
# Usage: get_tag_info "Dog"
#        echo "${tag_info[name]}"
#        echo "${tag_info[long_name]}"
#        echo "${tag_info[type]}"
#        echo "${tag_info[parent]}"
get_tag_info() {
  local tag="$1"
  local csv_data=$(get_tag_data "$tag")

  if [[ -z "$csv_data" ]]; then
    log_debug "No tag info found for '$tag'"
    return 1
  fi

  # Declare global associative array (bash 4+)
  declare -gA tag_info

  IFS="${DB_DELIMITER}" read -r tag_info[name] tag_info[long_name] tag_info[type] tag_info[parent] <<< "$csv_data"
}

# Individual accessor functions for single-value lookups
# Getting the name of a tag you already know seems redundant,
# but all the accessors include synonym and longname collapsing
get_tag_name() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r name _ _ _ <<< "$tag_data"
  echo "$name"
}

get_long_name(){
  tag_data=$(get_tag_data "$1");
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -z "$long_name" ]] ; then
    log_error "failed to find long name for $1"
  fi
  echo $long_name;
}

# This parses and trims a string, getting the short name from a long hierarchical name.
# Not a DB accessor like the rest.
get_short_name(){
  long_name="$1"
  local pipe_pattern='\|'
  # Get everything after the last pipe
  tag_name="${long_name##*|}"
  echo "$tag_name"
}

# Chop the rightmost part of a path string off.
# Basically identical to dirname?
# Inverse of get_shortname()
get_parent_name() {
  long_name="$1"
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    #tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi
  return $parent;
}

# Virtuially unused.
get_tag_type() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r _ _ type _ <<< "$tag_data"
  echo "$type"
}

# Lookup by name or longname. $tag may be any shape.
# It's valid for a tag to have no parent so may return empty.
get_parent(){
  tag=$1
  tag_data=$(get_tag_data "$tag")
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -n "$parent" ]] ; then
    log_debug "Parent of '$tag_name' is '$parent' ."
  else
    log_debug "'$tag_name' has no parent in the DB yet."
  fi
  echo $parent;
}

# Get all child tags of a parent tag
# Returns CSV list of child tag names
# Usage: get_tag_children "ParentTag"
# Returns: child1,child2,child3
get_tag_children(){
  local tag_input="${1:-}"  # Allow empty string for root/orphan tags

  local parent_name
  if [[ -z "$tag_input" ]]; then
    # Empty string means get root/orphan tags (parent IS NULL)
    parent_name=""
  else
    # Resolve parent tag to canonical name
    parent_name=$(get_tag_name "$tag_input")
    if [[ -z "$parent_name" ]]; then
      log_debug "Tag '$tag_input' not found, no children"
      return 1
    fi
  fi

  # Get all children of this parent (or roots if parent_name is empty)
  local SQL
  if [[ -z "$parent_name" ]]; then
    SQL="SELECT name FROM tags WHERE parent IS NULL OR parent = '' ORDER BY name;"
  else
    SQL="SELECT name FROM tags WHERE parent='$parent_name' ORDER BY name;"
  fi

  local result=$(sql_fast "$SQL")

  if [[ -n "$result" ]]; then
    # Convert newline-separated to CSV using string substitution (no read/heredoc)
    local csv="${result//$'\n'/,}"
#    if [[ -z "$parent_name" ]]; then
#      log_debug "Found root/orphan tags: $csv"
#    else
#      log_debug "Found children of '$parent_name': $csv"
#    fi
    echo "$csv"
    return 0
  else
#    if [[ -z "$parent_name" ]]; then
#      log_debug "No root/orphan tags found"
#    else
#      log_debug "'$parent_name' has no children"
#    fi
    return 1
  fi
}

# Set parent relationship using tag names as foreign keys.
# Parameters can be name, long_name, or synonym - will be resolved to name.
set_parent(){
  child_tag=$1
  parent_tag=$2
  log_notice "Setting parent of '$child_tag' to '$parent_tag'."

  # Resolve both to canonical names in case someone was using synonyms etc.
  parent_name=$(get_tag_name "$parent_tag")
  child_name=$(get_tag_name "$child_tag")

  if [[ -z "$child_name" ]]; then
    log_error "Cannot find name of tag tag '$child_tag'. The child tag must exist before it can have the parent set"
    return 1
  fi

  if [[ -z "$parent_name" ]]; then
    log_error "Cannot find name of parent tag '$parent_tag'. The parent tag must exist befor it is referenced."
    return 1
  fi

  SQL="
  PRAGMA foreign_keys = ON;
  UPDATE tags SET parent = '$parent_name' WHERE name = '$child_name';
  "
  sql_safe "$SQL"
  update_long_name_to_match_parent "$child_name"
}

# Transfer all children from one parent to another
# Reparents all children recursively using set_parent
# Usage: transfer_children SOURCE_PARENT DEST_PARENT
transfer_children() {
  local source_parent="$1"
  local dest_parent="$2"

  if [[ -z "$source_parent" || -z "$dest_parent" ]]; then
    log_error "transfer_children: requires source and destination parent tags"
    return 1
  fi

  local children=$(get_tag_children "$source_parent")
  if [[ -z "$children" ]]; then
    log_debug "No children to transfer from '$source_parent'"
    return 0
  fi

  log_info "Transferring children from '$source_parent' to '$dest_parent'..."
  IFS=',' read -ra children_array <<< "$children"
  for child in "${children_array[@]}"; do
    child=$(echo "$child" | xargs)
    [[ -n "$child" ]] && set_parent "$child" "$dest_parent"
  done
}

# Recursively delete all children of a parent tag
# Usage: delete_child_tags PARENT_TAG
delete_child_tags() {
  local parent_tag="$1"

  if [[ -z "$parent_tag" ]]; then
    log_error "delete_child_tags: requires parent tag"
    return 1
  fi

  local children=$(get_tag_children "$parent_tag")
  if [[ -z "$children" ]]; then
    log_debug "No children to delete for '$parent_tag'"
    return 0
  fi

  log_info "Deleting all children of '$parent_tag'..."
  IFS=',' read -ra children_array <<< "$children"
  for child in "${children_array[@]}"; do
    child=$(echo "$child" | xargs)
    [[ -n "$child" ]] && delete_tag "$child" --recursive
  done
}

# Orphan all children of a parent tag (set parent to NULL)
# Usage: orphan_child_tags PARENT_TAG
orphan_child_tags() {
  local parent_tag="$1"

  if [[ -z "$parent_tag" ]]; then
    log_error "orphan_child_tags: requires parent tag"
    return 1
  fi

  local children=$(get_tag_children "$parent_tag")
  if [[ -z "$children" ]]; then
    log_debug "No children to orphan for '$parent_tag'"
    return 0
  fi

  log_info "Orphaning all children of '$parent_tag'..."
  SQL="
  PRAGMA foreign_keys = ON;
  UPDATE tags SET parent = NULL WHERE parent='$parent_tag';
  "
  sql_safe "$SQL"
}

# Delete a tag from the database
# Handles child tags based on --recursive or --orphan option
# Usage: delete_tag TAG_NAME [--recursive|--orphan]
#   --recursive: Delete the tag and all its children recursively (default behavior)
#   --orphan: Delete the tag but set children's parent to NULL (keep orphaned tags)
#
# Returns:
#   0 on success
#   1 if tag not found or error during deletion
#
delete_tag() {
  local tag_input="$1"
  local child_mode="${2:-recursive}"  # default to recursive if not specified

  if [[ -z "$tag_input" ]]; then
    log_error "delete_tag: tag name required"
    return 1
  fi

  # Validate child_mode
  if [[ "$child_mode" != "recursive" && "$child_mode" != "orphan" ]]; then
    log_error "delete_tag: invalid mode '$child_mode' (use --recursive or --orphan)"
    return 1
  fi

  # Resolve tag to canonical name
  local tag_name=$(get_tag_name "$tag_input")
  if [[ -z "$tag_name" ]]; then
    log_error "delete_tag: tag '$tag_input' not found in database"
    return 1
  fi

  log_notice "Deleting tag '$tag_name' (mode: $child_mode)"

  # Handle children based on mode
  if [[ "$child_mode" == "recursive" ]]; then
    delete_child_tags "$tag_name"
  elif [[ "$child_mode" == "orphan" ]]; then
    orphan_child_tags "$tag_name"
  fi

  # Delete synonyms pointing to this tag
  local SQL_del_synonyms="DELETE FROM synonyms WHERE canonic='$tag_name';"
  sql_fast "$SQL_del_synonyms" > /dev/null 2>&1

  # Delete the tag itself
  local SQL_del_tag="PRAGMA foreign_keys = ON; DELETE FROM tags WHERE name='$tag_name';"
  if sql_safe "$SQL_del_tag"; then
    log_success "Tag '$tag_name' deleted successfully"
    return 0
  else
    log_error "Failed to delete tag '$tag_name'"
    return 1
  fi
}

# Combine two tags by merging one into another
# Redirects all references from secondary_tag to canonic_tag, then deletes secondary_tag
# Usage: combine_tags SECONDARY_TAG CANONIC_TAG
#
# This function:
#   1. Validates both tags exist
#   2. Updates all tags that have secondary_tag as parent to use canonic_tag instead
#   3. Deletes the secondary_tag from the database
#   4. Cleans up synonyms for the deleted tag
#
# Returns:
#   0 on success
#   1 if either tag is not found or merge fails
#
combine_tags() {
  local secondary_input="$1"
  local canonic_input="$2"

  if [[ -z "$secondary_input" || -z "$canonic_input" ]]; then
    log_error "combine_tags: requires two tag names (secondary_tag canonic_tag)"
    return 1
  fi

  # Resolve both tags to canonical names
  local secondary_tag=$(get_tag_name "$secondary_input")
  if [[ -z "$secondary_tag" ]]; then
    log_error "combine_tags: secondary tag '$secondary_input' not found"
    return 1
  fi

  local canonic_tag=$(get_tag_name "$canonic_input")
  if [[ -z "$canonic_tag" ]]; then
    log_error "combine_tags: canonic tag '$canonic_input' not found"
    return 1
  fi

  if [[ "$secondary_tag" == "$canonic_tag" ]]; then
    log_error "combine_tags: tags are the same, nothing to combine"
    return 1
  fi

  log_notice "Combining tag '$secondary_tag' into '$canonic_tag'..."

  # Transfer children from secondary to canonic tag
  transfer_children "$secondary_tag" "$canonic_tag"

  # Transfer synonyms from secondary_tag to canonic_tag
  SQL="UPDATE synonyms SET canonic='$canonic_tag' WHERE canonic='$secondary_tag';"
  sql_fast "$SQL" > /dev/null 2>&1

  # Delete the secondary tag (all children already reparented)
  if delete_tag "$secondary_tag"; then
    log_success "Successfully combined '$secondary_tag' into '$canonic_tag'"
    return 0
  else
    log_error "Failed to delete secondary tag '$secondary_tag'"
    return 1
  fi
}

# Adds a synonym to a tag. Avoids duplicates.
# May force the cacnonic tag into existance by creating it.
# Resolves canonic to tag name for foreign key relationship
# usage:
# set_synonym canonic synonym
# TODO - cehck for duplicates, and re-parent any items currently using the synonym as parent
set_synonym(){
  canonic=$1
  synonym=$2

  # Resolve to canonical tag name
  canonic_name=$(get_tag_name "$canonic")
  if [[ -z "$canonic_name" ]]; then
    log_error "No tag found for '$canonic'"
    return 1
  fi

  # Normalize synonym to canonical form if it's already a synonym
  local canonical_synonym=$(get_tag_name "$synonym" 2>/dev/null)
  if [[ -n "$canonical_synonym" ]]; then
    # It's an existing synonym/tag, use its canonical form
    synonym="$canonical_synonym"
  fi

  # Check if the synonym already exists
  SQL="SELECT synonym FROM synonyms WHERE synonym='$synonym';"
  result=$(sql_fast "$SQL")

  # If the synonym doesn't exist, create it
  if [ -z "$result" ]; then
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO synonyms (synonym, canonic) VALUES ('$synonym', '$canonic_name');
    ";
    sql_safe "$SQL"
    log_notice "Added synonym '$synonym' for tag '$canonic_name'."
  else
    log_debug "Synonym '$synonym' already exists."
  fi
}

# Helper function that sets global variables (alternative to Pattern 1)
# Usage: parse_tag_data "$(get_tag_data 'Dog')"
#        echo "$tag_name $long_name $type $parent"
# Note: Variables are GLOBAL (no local keyword) so available to caller
# Can also be used to unset these variables.
parse_tag_data() {
  local csv_data="$1"
  if [[ -z "$csv_data" ]]; then
    tag_name=""
    long_name=""
    type=""
    parent=""
    return 1
  fi
  # These variables are NOT local, so they're set in the caller's scope
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$csv_data"
}

# Housekeeping function to ensure long_name matches parentage
# usage: update_long_name_to_match_parent "TagName"
update_long_name_to_match_parent(){
  tag_name=$1
  parent=$(get_parent "$tag_name")
  parent_long_name=$(get_long_name "$parent")
  current_long_name=$(get_long_name "$tag_name")
  expected_long_name="${parent_long_name}|${tag_name}"
  if [[ "$current_long_name" != "$expected_long_name" ]] ; then
    log_notice "Updating long_name of '$tag_name' from '$current_long_name' to '$expected_long_name' ."
    SQL="
    PRAGMA foreign_keys = ON;
    UPDATE tags SET long_name = '$expected_long_name' WHERE name = '$tag_name';
    "
    sql_safe "$SQL"
  else
    log_debug "Long name of '$tag_name' is already correct: '$expected_long_name'."
  fi
}

# Update the tag hierarchy based on tag names with slashes.
# This is housekeeping, to deal with data thant may have been imported roughly
# Tags with delimiters in their names will have their parent set to the leftmost parts
# For example, "Location|Inside|Bedroom" will have a parent of "Location|Inside"
# The delimiter is conventiolnally "|" to conform with Adobe Bridge HeirarchicalSubject
# but may be expanded to "/" or ":" instead.
#
# This is unused, and may be deprecated - was just to clean bad old data.
update_tag_hierarchy(){
  log_notice "Updating tag hierarchy..."
  DELIMITER="|";

  # Get all tags with slashes in their names
  SQL="SELECT name FROM tags WHERE name LIKE '%${DELIMITER}%';"
  tags_with_slashes=$(sql_fast "$SQL")

  # Process each tag
  if [ -n "$tags_with_slashes" ]; then
    # First, ensure all parent tags exist
    echo "$tags_with_slashes" | while read -r tag_name; do
      parent=$(get_parent_name "$tag_name")
      if [ -n "$parent" ]; then
        ensure_tag_exists "$parent" "container"
      fi
      set_parent "$tag_name" "$parent"
    done
    log_notice "Tag hierarchy updated successfully."
  else
    log_notice "No tags with ${DELIMITER} delimiters found."
  fi

  # Display the updated hierarchy
  log_notice "Displaying updated tag hierarchy:"
  dump_tags
}


# Diagnostic: List all tags in a column
# If a tag has synonyms, list each of them, indented, after the tag.
# If a tag has a parent, it will be displayed under its parent with indentation.
dump_tags(){
  # Get all root/orphan tags using the abstraction
  local root_tag_csv=$(get_tag_children "")
  if [[ -z "$root_tag_csv" ]]; then
    log_debug "No root tags to display"
    return 0
  fi

  # Process each root tag (convert CSV to array)
  local IFS=','
  local -a root_tags_array=($root_tag_csv)
  unset IFS

  for tag_name in "${root_tags_array[@]}"; do
    # Trim whitespace
    tag_name=$(echo "$tag_name" | xargs)
    [[ -z "$tag_name" ]] && continue

    # Get full tag data to check type
    local tag_data=$(get_tag_data "$tag_name")
    local long_name
    IFS="${DB_DELIMITER}" read -r tag_name long_name tag_type parent <<< "$tag_data"

    # Display the root tag
    if [ "$tag_type" = "container" ]; then
      printf "\033[90m%s\033[0m\n" "$tag_name [root]"
    else
      printf "%s\n" "$tag_name"
    fi

    # Display synonyms for this tag
    display_synonyms "$long_name" "  "

    # Display child tags recursively
    display_child_tags "$long_name" "|--"
  done
}


# Diagnostic Utility to check if the current scope has these variables set/
dump_tag_values(){
  echo "  name: $tag_name"
  echo "  long_name: $long_name"
  echo "  type: $type"
  echo "  parent: $parent"
}


# Helper function to display synonyms for a tag
display_synonyms(){
  local tag="$1"
  local indent="$2"

  # Resolve to canonical name (canonic column stores names)
  local tag_name=$(get_tag_name "$tag")
  if [[ -z "$tag_name" ]]; then
    return 0
  fi

  # Get all synonyms for this tag (tag_name is already canonical)
  SQL="SELECT synonym FROM synonyms WHERE canonic='$tag_name' ORDER BY synonym;"
  synonyms=$(sql_fast "$SQL")

  # List each synonym indented
  if [ -n "$synonyms" ]; then
    echo "$synonyms" | while read -r synonym; do
      printf "${indent}AKA: %s\n" "$synonym"
    done
  fi
}

# Helper function to display child tags recursively
# Expects tag identifier (name, long_name, or synonym) - will be resolved to name
display_child_tags(){
  local parent_tag="$1"
  local indent="$2"

  # Get all child tag names using abstraction layer
  local child_names=$(get_tag_children "$parent_tag")
  if [[ -z "$child_names" ]]; then
    return 0
  fi

  # Process each child tag name
  IFS=',' read -ra children_array <<< "$child_names"
  for tag_name in "${children_array[@]}"; do
    tag_name=$(echo "$tag_name" | xargs)  # Trim whitespace
    [[ -z "$tag_name" ]] && continue

    # Fetch full tag data for display
    local tag_data=$(get_tag_data "$tag_name")
    IFS="${DB_DELIMITER}" read -r tag_name long_name tag_type parent <<< "$tag_data"

    # Display the child tag with indentation
    if [ "$tag_type" = "container" ]; then
      printf "${indent}\033[90m%s\033[0m\n" "$tag_name"
    else
      printf "${indent}%s\n" "$tag_name"
    fi

    # Display synonyms for this child tag
    display_synonyms "$long_name" "${indent}  "

    # Recursively display this child's children
    display_child_tags "$tag_name" "${indent}${indent}"
  done
}

# Extract EXIF tags from a media file
# Pulls tags from multiple EXIF metadata fields and returns deduplicated list
# Checks MIME type to ensure file is supported by exiftool
#
# Usage: extract_exif_tags "/path/to/file.jpg"
# Returns: Newline-separated list of tag strings (or empty if unsupported/no tags)
#
# Tag fields checked (in order):
#   HierarchicalSubject, Subject, Keywords, Categories, CatalogSets, TagsList
#
# Pipe-delimited entries (Location|Inside|Bedroom) are expanded to all levels
# Results are deduplicated via sort -u
#
extract_exif_tags() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        log_error "extract_exif_tags: File not found: $file_path"
        return 1
    fi

    # Check if this file is supported by exiftool (has MIME type)
    local mime_type=$(exiftool -s -S -MimeType "$file_path" 2>/dev/null)
    if [[ -z "$mime_type" ]]; then
        log_debug "extract_exif_tags: $file_path - no EXIF support (MIME type not found)"
        return 1
    fi

    local all_tags=()
    local tag_fields=( HierarchicalSubject Subject Keywords Categories CatalogSets TagsList )

    # Extract each tag field
    for field in "${tag_fields[@]}"; do
        local field_values=$(exiftool -s -s -s "-${field}" "$file_path" 2>/dev/null)

        if [[ -n "$field_values" ]]; then
            # Split by newlines and commas (exiftool uses both for multiple values)
            while IFS= read -r line; do
                # Split by comma as well
                IFS=',' read -ra items <<< "$line"
                for item in "${items[@]}"; do
                    # Trim whitespace
                    item=$(echo "$item" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                    if [[ -n "$item" ]]; then
                        all_tags+=("$item")
                    fi
                done
            done <<< "$field_values"
        fi
    done

    # Deduplicate and output
    if [[ ${#all_tags[@]} -gt 0 ]]; then
        printf '%s\n' "${all_tags[@]}" | sort -u
        return 0
    fi

    return 1
}

# Parallel file processing utility
# Processes all files recursively in the input arguments using parallel execution.
# Expects the caller to define a 'processFile' function and export any additional
# functions needed (e.g., export -f processWebpFile if processFile depends on it).
# Note: Feedback from sub-processes may get jumbled due to parallel execution.
# Note: Uses BSD xargs syntax (macOS) - -0: null-separated, -P: parallel, -I: replace
parallelProcessFiles() {
    export -f processFile;
    export SCRIPT_DIR;
    find "$@" -type f -print0 | xargs -0 -P 4 -I {} bash -c 'processFile "$1"' _ "{}"
}

# Initialize database when library is sourced
verify_database
open_database
