#!/bin/bash

# utilities re-used by the media processing tools

UTIL_DIR=${UTIL_DIR:-~/.media_processing}
mkdir -p "$UTIL_DIR"

log_notice(){
  echo "$1"  >&2
}
log_debug(){
  printf "\033[93m$1\033[0m\n"  >&2
}
log_error(){
  printf "\033[31m$1\033[0m\n" >&2
}

MEDIA_DB="${MEDIA_DB:-${UTIL_DIR}/media.sqlite}"
log_notice "MEDIA_DB=$MEDIA_DB"

create_database(){
  echo ".open $MEDIA_DB" | sqlite3
  log_notice "Initializing database $MEDIA_DB"

  # Create all tables at once with foreign key constraints
  SQL="PRAGMA foreign_keys = ON;
  CREATE TABLE tag_types (type TEXT PRIMARY KEY);
  CREATE TABLE tags (name TEXT PRIMARY KEY, type TEXT, parent TEXT,
    FOREIGN KEY (type) REFERENCES tag_types(type),
    FOREIGN KEY (parent) REFERENCES tags(name));
  CREATE TABLE synonyms (synonym TEXT PRIMARY KEY, canonic TEXT,
    FOREIGN KEY (canonic) REFERENCES tags(name));"
  echo "$SQL" | sqlite3 "$MEDIA_DB"
  log_notice "Created tables in database $MEDIA_DB"

  # Insert initial data
  SQL="
  INSERT INTO tag_types (type) VALUES ('container');
  INSERT INTO tag_types (type) VALUES ('leaf');
  "
  echo "$SQL" | sqlite3 "$MEDIA_DB"

  log_notice "Database $MEDIA_DB is ready"
}
drop_database(){
  rm "$MEDIA_DB"
  log_notice "Dropped database $MEDIA_DB"
}



# Check if a tag exists in the database, and create it if not
# usage: ensure_tag_exists tag_name [tag_type] [parent]
ensure_tag_exists(){
  tag_name=$1
  tag_type=${2:-leaf}  # Default to 'leaf' if no type is provided
  parent=$3            # Optional parent tag

  # Check if the tag exists
  SQL="SELECT name, type, parent FROM tags WHERE name='$tag_name';"
  result=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

  # If the tag doesn't exist, create it
  if [ -z "$result" ]; then
    log_notice "Tag '$tag_name' does not exist. Creating it with type '$tag_type'..."

    # If parent is provided, include it in the INSERT statement
    if [ -n "$parent" ]; then
      # Check if the parent tag exists
      SQL="SELECT name FROM tags WHERE name='$parent';"
      parent_exists=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

      # If the parent doesn't exist, create it
      if [ -z "$parent_exists" ]; then
        # Recursively ensure the parent tag exists (as a container)
        ensure_tag_exists "$parent" "container"
      fi

      SQL="
      PRAGMA foreign_keys = ON;
      INSERT INTO tags (name, type, parent) VALUES ('$tag_name', '$tag_type', '$parent');
      "
    else
      SQL="
      PRAGMA foreign_keys = ON;
      INSERT INTO tags (name, type) VALUES ('$tag_name', '$tag_type');
      "
    fi

    echo "$SQL" | sqlite3 "$MEDIA_DB"
  else
    log_debug "Tag '$tag_name' already exists."

    # If parent is provided and the tag exists but has no parent, update it
    if [ -n "$parent" ]; then
      # Extract the current parent from the result
      IFS='|' read -r _ _ current_parent <<< "$result"

      # If the tag has no parent, update it
      if [ -z "$current_parent" ]; then
        # Check if the parent tag exists
        SQL="SELECT name FROM tags WHERE name='$parent';"
        parent_exists=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

        # If the parent doesn't exist, create it
        if [ -z "$parent_exists" ]; then
          # Recursively ensure the parent tag exists
          ensure_tag_exists "$parent"
        fi

        # Update the tag with the parent
        SQL="
        PRAGMA foreign_keys = ON;
        UPDATE tags SET parent = '$parent' WHERE name = '$tag_name';
        "
        echo "$SQL" | sqlite3 "$MEDIA_DB"
        log_notice "Updated tag '$tag_name' with parent '$parent'."
      fi
    fi
  fi
}

# usage:
# set_synonym_for canonic synonym
set_synonym_for(){
  canonic=$1
  synonym=$2

  # Ensure the canonic tag exists before setting the synonym
  ensure_tag_exists "$canonic"

  # Check if the synonym already exists
  SQL="SELECT synonym FROM synonyms WHERE synonym='$synonym';"
  result=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

  # If the synonym doesn't exist, create it
  if [ -z "$result" ]; then
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO synonyms (synonym, canonic) VALUES ('$synonym', '$canonic');
    ";
    echo "$SQL" | sqlite3 "$MEDIA_DB"
    log_notice "Added synonym '$synonym' for tag '$canonic'."
  else
    log_debug "Synonym '$synonym' already exists."
  fi
}

# List all tags in a column
# If a tag has synonyms, list each of them, indented, after the tag.
# If a tag has a parent, it will be displayed under its parent with indentation.
dump_tags(){
  # First, get all root tags (tags with no parent)
  SQL="SELECT name, type FROM tags WHERE parent IS NULL OR parent = '' ORDER BY name;"
  root_tags=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

  # Process each root tag
  echo "$root_tags" | while IFS='|' read -r tag_name tag_type; do
    # Display the root tag
    if [ "$tag_type" = "container" ]; then
      printf "\033[90m%s\033[0m\n" "$tag_name [root]"
    else
      printf "%s\n" "$tag_name"
    fi

    # Display synonyms for this tag
    display_synonyms "$tag_name" "  "

    # Display child tags recursively
    display_child_tags "$tag_name" "|--"
  done
}

dump_db() {
  tables=( $(echo ".tables" | sqlite3 "$MEDIA_DB" ) )
  for table in "${tables[@]}"; do
    echo -e "\nTable: $table"
    SQL="SELECT * FROM $table;"
    echo "$SQL" | sqlite3 -column -header  "$MEDIA_DB"
  done
}

# Update the tag hierarchy based on tag names with slashes
# Tags with slashes in their names will have their parent set to the leftmost parts
# For example, "Location/Inside/Bedroom" will have a parent of "Location/Inside"
update_tag_hierarchy(){
  log_notice "Updating tag hierarchy..."

  # Get all tags with slashes in their names
  SQL="SELECT name FROM tags WHERE name LIKE '%/%';"
  tags_with_slashes=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

  # Process each tag
  if [ -n "$tags_with_slashes" ]; then
    # First, ensure all parent tags exist
    echo "$tags_with_slashes" | while read -r tag_name; do
      parent=$(parse_parent_of "$tag_name")
      # Split the tag name by slashes
      IFS='/' read -ra parts <<< "$tag_name"
      # If there's only one part, skip (no parent)
      if [ ${#parts[@]} -le 1 ]; then
        continue
      fi

      # Ensure all parent tags in the hierarchy exist
      current_path=""
      for ((i=0; i<${#parts[@]}-1; i++)); do
        if [ $i -eq 0 ]; then
          current_path="${parts[$i]}"
        else
          current_path="$current_path/${parts[$i]}"
        fi

        # Ensure this parent tag exists as a container
        ensure_tag_exists "$current_path" "container"
      done
    done

    # Now set the parent for each tag
    # re-read the list to take into account any interim tags that may have been added.
    tags_with_slashes=$(echo "$SQL" | sqlite3 "$MEDIA_DB")
    echo "$tags_with_slashes" | while read -r tag_name; do
      # Split the tag name by slashes
      IFS='/' read -ra parts <<< "$tag_name"

      # If there's only one part, skip (no parent)
      if [ ${#parts[@]} -le 1 ]; then
        continue
      fi

      # Determine the parent tag
      parent_tag=""
      if [ ${#parts[@]} -eq 2 ]; then
        # For tags with one slash (e.g., "Location/Inside"), the parent is the first part
        parent_tag="${parts[0]}"
      else
        # For tags with multiple slashes, build the parent path
        parent_tag=""
        for ((i=0; i<${#parts[@]}-1; i++)); do
          if [ $i -eq 0 ]; then
            parent_tag="${parts[$i]}"
          else
            parent_tag="$parent_tag/${parts[$i]}"
          fi
        done
      fi

      log_notice "Setting parent of '$tag_name' to '$parent_tag'"

      # Update the tag's parent
      SQL="PRAGMA foreign_keys = ON;
      UPDATE tags SET parent = '$parent_tag' WHERE name = '$tag_name';"
      echo "$SQL" | sqlite3 "$MEDIA_DB"
    done

    log_notice "Tag hierarchy updated successfully."
  else
    log_notice "No tags with slashes found."
  fi

  # Display the updated hierarchy
  log_notice "Displaying updated tag hierarchy:"
  dump_tags
}

# chop the rightmost part of a path off.
# Basically identical to dirname?
parse_parent_of(){
  local tag_name="$1"
  # Split the tag name by slashes
  mapfile -d '/' -t parts < <(echo -n "$tag_name")

  # If there's only one part, skip (no parent)
  if [ ${#parts[@]} -le 1 ]; then
    return 0
  fi
  # For tags with multiple slashes, build the parent path
  parent_tag=""
  for ((i=0; i<${#parts[@]}-1; i++)); do
    if [ $i -eq 0 ]; then
      parent_tag="${parts[$i]}"
    else
      parent_tag="$parent_tag/${parts[$i]}"
    fi
  done
  echo $parent_tag
}

# Helper function to display synonyms for a tag
display_synonyms(){
  local tag_name="$1"
  local indent="$2"

  # Get all synonyms for this tag
  SQL="SELECT synonym FROM synonyms WHERE canonic='$tag_name' ORDER BY synonym;"
  synonyms=$(echo "$SQL" | sqlite3 "$MEDIA_DB")

  # List each synonym indented
  if [ -n "$synonyms" ]; then
    echo "$synonyms" | while read -r synonym; do
      printf "${indent}AKA: %s\n" "$synonym"
    done
  fi
}

# Helper function to display child tags recursively
display_child_tags(){
  local parent_tag="$1"
  local indent="$2"

  # Get all child tags for this parent
  SQL="SELECT name, type FROM tags WHERE parent='$parent_tag' ORDER BY name;"
  child_tags=$(echo "$SQL" | sqlite3 "$MEDIA_DB")
  # Process each child tag
  if [ -n "$child_tags" ]; then
    echo "$child_tags" | while IFS='|' read -r tag_name tag_type; do
      # Display the child tag with indentation
      if [ "$tag_type" = "container" ]; then
        printf "${indent}\033[90m%s\033[0m\n" "$tag_name"
      else
        printf "${indent}%s\n" "$tag_name"
      fi

      # Display synonyms for this child tag
      display_synonyms "$tag_name" "${indent}  "

      # Recursively display this child's children with increased indentation
      display_child_tags "$tag_name" "${indent}${indent}"
    done
  fi
}

# Require sqlite3 or die
if ! command -v sqlite3 >/dev/null 2>&1; then
  log_error "sqlite3 is required"
  exit 1
fi

# Check if the database file exists and is a valid SQLite database
if [ ! -f "$MEDIA_DB" ]; then
  log_notice "Database file does not exist. Creating it..."
  create_database;
else
  # Check if it's a valid SQLite database by trying to run a simple query
  if ! echo ".tables" | sqlite3 "$MEDIA_DB" &>/dev/null; then
    log_notice "Database file exists but appears to be invalid. Recreating it..."
    drop_database;
    create_database;
  else
    log_notice "Database file exists and is valid."
  fi
fi

