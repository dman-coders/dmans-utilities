#!/usr/bin/env bash

# utilities re-used by the media processing tools
# Define MEDIA_DB path before initializing to override default location.

UTIL_DIR=${MEDIA_LIB_DIR:-~/.media_processing}
mkdir -p "$MEDIA_LIB_DIR"
MEDIA_DB="${MEDIA_DB:-${MEDIA_LIB_DIR}/media.sqlite}"

# Source SQLite database management functions
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$LIB_DIR/sqlite.lib"
source "$LIB_DIR/../feedback.lib"


# Check if a tag exists in the database, and create it if not
# usage: ensure_tag_exists tag_name [tag_type] [parent]
ensure_tag_exists(){
  local tag_name=$1
  local long_name=$tag_name
  local tag_type=${2:-leaf}  # Default to 'leaf' if no type is provided
  local parent=$3            # Optional parent tag

  if [[ -z "$tag_name" ]] ; then
    log_error "No tag name for $0"
    return 1
  fi

  # If it appears to be a '|' delimited heirarchical tagname, deal with that
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi

  # Check if the tag exists.
  tag_data=$(get_tag_data "$tag_name");

  # If the tag doesn't exist, create it
  if [ -z "$tag_data" ]; then
    log_notice "Tag '$tag_name' does not exist. Creating it with type '$tag_type'..."
    # create the entry, then add the parent association after
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO tags (name, long_name, type) VALUES ('$tag_name', '$long_name', '$tag_type');
    "
    sql_safe "$SQL"
  else
    log_debug "Tag '$tag_name' already exists."
  fi

  # If parent is provided and the tag exists but has no parent, update it.
  current_parent=$(get_parent "$tag_name");
  if [[ -n "$parent" && -z "$current_parent" ]]; then
    log_info "Tag '$tag_name' should have parent '$parent' . Ensuring parent exists first."
    ensure_tag_exists "$parent"
    # That process may have resolved a synonym, so re-resolve to get the canonic parent name
    parent=$(get_tag_name "$parent")
    log_info "Ensuring parentage of '$tag_name' is in place."
    set_parent "$tag_name" "$parent"
  fi
  # log_info "Tag '$tag_name' exists"
}

# Will search for a tag by name, or synonym.
# returns a csv listing "name, long_name, type, parent"
# That has to be parsed by the caller.
get_tag_data(){
  tag_name=$1
  long_name=$tag_name
  tag_name=$(get_short_name "$tag_name")
  if [[ -n "$2" ]] ; then
    log_error "Unexpected argument '$2' . Quote tags when using get_tag.";
    exit 1;
  fi
  # Usually do a direct shortname match.
  # Fall back to synonym after that
  # If asked for long_name, return that first
  #SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$long_name';"
  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$long_name' OR tags.name='$tag_name';"
  result=$(sql_fast "$SQL")

  #if [ -z "$result" ]; then
  #  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE name='$tag_name';"
  #  result=$(sql_fast "$SQL")
  #fi

  # Join the tags to the synonyms table to find the result by synonym
  if [ -z "$result" ]; then
    # log_debug "Looking for synonyms of '$tag_name'"
    SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM synonyms INNER JOIN tags ON synonyms.canonic = tags.name WHERE synonyms.synonym='$tag_name';"
    result=$(sql_fast "$SQL")
    if [ -n "$result" ]; then
      log_info "Using synonym for '$tag_name' "
    fi
  fi
  if [ -z "$result" ]; then
    log_info "Could not find an entry or synonym matching $tag_name"
  fi

  echo $result;
}

# Load tag data into an associative array for convenient access
# Usage: get_tag_info "Dog"
#        echo "${tag_info[name]}"
#        echo "${tag_info[long_name]}"
#        echo "${tag_info[type]}"
#        echo "${tag_info[parent]}"
get_tag_info() {
  local tag="$1"
  local csv_data=$(get_tag_data "$tag")

  if [[ -z "$csv_data" ]]; then
    log_debug "No tag info found for '$tag'"
    return 1
  fi

  # Declare global associative array (bash 4+)
  declare -gA tag_info

  IFS="${DB_DELIMITER}" read -r tag_info[name] tag_info[long_name] tag_info[type] tag_info[parent] <<< "$csv_data"
}

# Individual accessor functions for single-value lookups
# Getting the name of a tag you already know seems redundant,
# but all the accessors include synonym and longname collapsing
get_tag_name() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r name _ _ _ <<< "$tag_data"
  echo "$name"
}

get_long_name(){
  tag_data=$(get_tag_data "$1");
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -z "$long_name" ]] ; then
    log_error "failed to find long name for $1"
  fi
  echo $long_name;
}

# This parses and trims a string, getting the short name from a long hierarchical name.
# Not a DB accessor like the rest.
get_short_name(){
  long_name="$1"
  local pipe_pattern='\|'
  # Get everything after the last pipe
  tag_name="${long_name##*|}"
  echo "$tag_name"
}

# Chop the rightmost part of a path string off.
# Basically identical to dirname?
# Inverse of get_shortname()
get_parent_name() {
  long_name="$1"
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    #tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi
  return $parent;
}

# Virtuially unused.
get_tag_type() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r _ _ type _ <<< "$tag_data"
  echo "$type"
}

# Lookup by name or longname. $tag may be any shape.
# It's valid for a tag to have no parent so may return empty.
get_parent(){
  tag=$1
  tag_data=$(get_tag_data "$tag")
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -n "$parent" ]] ; then
    log_debug "Parent of '$tag_name' is '$parent' ."
  else
    log_debug "'$tag_name' has no parent in the DB yet."
  fi
  echo $parent;
}

# Set parent relationship using tag names as foreign keys.
# Parameters can be name, long_name, or synonym - will be resolved to name.
set_parent(){
  child_tag=$1
  parent_tag=$2
  log_notice "Setting parent of '$child_tag' to '$parent_tag'."

  # Resolve both to canonical names in case someone was using synonyms etc.
  parent_name=$(get_tag_name "$parent_tag")
  child_name=$(get_tag_name "$child_tag")

  if [[ -z "$child_name" ]]; then
    log_error "Cannot find name of tag tag '$child_tag'. The child tag must exist before it can have the parent set"
    return 1
  fi

  if [[ -z "$parent_name" ]]; then
    log_error "Cannot find name of parent tag '$parent_tag'. The parent tag must exist befor it is referenced."
    return 1
  fi

  SQL="
  PRAGMA foreign_keys = ON;
  UPDATE tags SET parent = '$parent_name' WHERE name = '$child_name';
  "
  sql_safe "$SQL"
  update_long_name_to_match_parent "$child_name"
}

# Adds a synonym to a tag. Avoids duplicates.
# May force the cacnonic tag into existance by creating it.
# Resolves canonic to tag name for foreign key relationship
# usage:
# set_synonym canonic synonym
# TODO - cehck for duplicates, and re-parent any items currently using the synonym as parent
set_synonym(){
  canonic=$1
  synonym=$2

  # Resolve to canonical tag name
  canonic_name=$(get_tag_name "$canonic")
  if [[ -z "$canonic_name" ]]; then
    log_error "No tag found for '$canonic'"
    return 1
  fi

  # Ensure the canonic tag exists before setting the synonym
  ensure_tag_exists "$canonic"

  # Check if the synonym already exists
  SQL="SELECT synonym FROM synonyms WHERE synonym='$synonym';"
  result=$(sql_fast "$SQL")

  # If the synonym doesn't exist, create it
  if [ -z "$result" ]; then
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO synonyms (synonym, canonic) VALUES ('$synonym', '$canonic_name');
    ";
    sql_safe "$SQL"
    log_notice "Added synonym '$synonym' for tag '$canonic_name'."
  else
    log_debug "Synonym '$synonym' already exists."
  fi
}

# Helper function that sets global variables (alternative to Pattern 1)
# Usage: parse_tag_data "$(get_tag_data 'Dog')"
#        echo "$tag_name $long_name $type $parent"
# Note: Variables are GLOBAL (no local keyword) so available to caller
# Can also be used to unset these variables.
parse_tag_data() {
  local csv_data="$1"
  if [[ -z "$csv_data" ]]; then
    tag_name=""
    long_name=""
    type=""
    parent=""
    return 1
  fi
  # These variables are NOT local, so they're set in the caller's scope
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$csv_data"
}

# Housekeeping function to ensure long_name matches parentage
# usage: update_long_name_to_match_parent "TagName"
update_long_name_to_match_parent(){
  tag_name=$1
  parent=$(get_parent "$tag_name")
  parent_long_name=$(get_long_name "$parent")
  current_long_name=$(get_long_name "$tag_name")
  expected_long_name="${parent_long_name}|${tag_name}"
  if [[ "$current_long_name" != "$expected_long_name" ]] ; then
    log_notice "Updating long_name of '$tag_name' from '$current_long_name' to '$expected_long_name' ."
    SQL="
    PRAGMA foreign_keys = ON;
    UPDATE tags SET long_name = '$expected_long_name' WHERE name = '$tag_name';
    "
    sql_safe "$SQL"
  else
    log_debug "Long name of '$tag_name' is already correct: '$expected_long_name'."
  fi
}

# Update the tag hierarchy based on tag names with slashes.
# This is housekeeping, to deal with data thant may have been imported roughly
# Tags with delimiters in their names will have their parent set to the leftmost parts
# For example, "Location|Inside|Bedroom" will have a parent of "Location|Inside"
# The delimiter is conventiolnally "|" to conform with Adobe Bridge HeirarchicalSubject
# but may be expanded to "/" or ":" instead.
#
# This is unused, and may be deprecated - was just to clean bad old data.
update_tag_hierarchy(){
  log_notice "Updating tag hierarchy..."
  DELIMITER="|";

  # Get all tags with slashes in their names
  SQL="SELECT name FROM tags WHERE name LIKE '%${DELIMITER}%';"
  tags_with_slashes=$(sql_fast "$SQL")

  # Process each tag
  if [ -n "$tags_with_slashes" ]; then
    # First, ensure all parent tags exist
    echo "$tags_with_slashes" | while read -r tag_name; do
      parent=$(get_parent_name "$tag_name")
      if [ -n "$parent" ]; then
        ensure_tag_exists "$parent" "container"
      fi
      set_parent "$tag_name" "$parent"
    done
    log_notice "Tag hierarchy updated successfully."
  else
    log_notice "No tags with ${DELIMITER} delimiters found."
  fi

  # Display the updated hierarchy
  log_notice "Displaying updated tag hierarchy:"
  dump_tags
}


# Diagnostic: List all tags in a column
# If a tag has synonyms, list each of them, indented, after the tag.
# If a tag has a parent, it will be displayed under its parent with indentation.
dump_tags(){
  # First, get all root tags (tags with no parent)
  SQL="SELECT name, long_name FROM tags WHERE parent IS NULL OR parent = '' ORDER BY name;"
  root_tags=$(sql_fast "$SQL")

  # Process each root tag
  echo "$root_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name; do
    # Display the root tag
    if [ "$tag_type" = "container" ]; then
      printf "\033[90m%s\033[0m\n" "$tag_name [root]"
    else
      printf "%s\n" "$tag_name"
    fi

    # Display synonyms for this tag
    display_synonyms "$long_name" "  "

    # Display child tags recursively
    display_child_tags "$long_name" "|--"
  done
}


# Diagnostic Utility to check if the current scope has these variables set/
dump_tag_values(){
  echo "  name: $tag_name"
  echo "  long_name: $long_name"
  echo "  type: $type"
  echo "  parent: $parent"
}


# Helper function to display synonyms for a tag
display_synonyms(){
  local tag="$1"
  local indent="$2"

  # Resolve to canonical name (canonic column stores names)
  local tag_name=$(get_tag_name "$tag")
  if [[ -z "$tag_name" ]]; then
    return 0
  fi

  # Get all synonyms for this tag
  SQL="SELECT synonym FROM synonyms WHERE canonic='$tag_name' ORDER BY synonym;"
  synonyms=$(sql_fast "$SQL")

  # List each synonym indented
  if [ -n "$synonyms" ]; then
    echo "$synonyms" | while read -r synonym; do
      printf "${indent}AKA: %s\n" "$synonym"
    done
  fi
}

# Helper function to display child tags recursively
# Expects tag identifier (name, long_name, or synonym) - will be resolved to name
display_child_tags(){
  local parent_tag="$1"
  local indent="$2"

  # Resolve parent_tag to canonical name (parent column stores names)
  local parent_name=$(get_tag_name "$parent_tag")
  if [[ -z "$parent_name" ]]; then
    return 0
  fi

  # Get all child tags for this parent
  SQL="SELECT name, long_name, type FROM tags WHERE parent='$parent_name' ORDER BY name;"
  child_tags=$(sql_fast "$SQL")
  # Process each child tag
  if [ -n "$child_tags" ]; then
    echo "$child_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name tag_type; do
      # Display the child tag with indentation
      if [ "$tag_type" = "container" ]; then
        printf "${indent}\033[90m%s\033[0m\n" "$tag_name"
      else
        printf "${indent}%s\n" "$tag_name"
      fi

      # Display synonyms for this child tag
      display_synonyms "$long_name" "${indent}  "

      # Recursively display this child's children (pass name for FK lookup)
      display_child_tags "$tag_name" "${indent}${indent}"
    done
  fi
}

# Parallel file processing utility
# Processes all files recursively in the input arguments using parallel execution.
# Expects the caller to define a 'processFile' function and export any additional
# functions needed (e.g., export -f processWebpFile if processFile depends on it).
# Note: Feedback from sub-processes may get jumbled due to parallel execution.
# Note: Uses BSD xargs syntax (macOS) - -0: null-separated, -P: parallel, -I: replace
parallalProcessFiles() {
    export -f processFile;
    find "$@" -type f -print0 | xargs -0 -P 4 -I {} bash -c 'processFile "$1"' _ "{}"
}

# Initialize database when library is sourced
verify_database
open_database
