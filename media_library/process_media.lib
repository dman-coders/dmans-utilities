#!/usr/bin/env bash

# utilities re-used by the media processing tools
UTIL_DIR=${UTIL_DIR:-~/.media_processing}
mkdir -p "$UTIL_DIR"
MEDIA_DB="${MEDIA_DB:-${UTIL_DIR}/media.sqlite}"

# Database output delimiter (CSV format to avoid collision with | in tag names)
DB_DELIMITER=','

log_notice(){
  echo "$1"  >&2
}
log_debug(){
  printf "\033[93m$1\033[0m\n"  >&2
}
log_info(){
  # ligh blue
  printf "\033[94m$1\033[0m\n"  >&2
}
log_error(){
  printf "\033[31m$1\033[0m\n" >&2
}


create_database(){
  echo ".open $MEDIA_DB" | sqlite3
  log_notice "Initializing database $MEDIA_DB"

  # Create all tables at once with foreign key constraints
  # name is the primary key and used for all foreign key relationships
  # long_name is a cosmetic/convenience field for display and hierarchy definition
  SQL="PRAGMA foreign_keys = ON;
  CREATE TABLE tag_types (type TEXT PRIMARY KEY);
  CREATE TABLE tags (
    name TEXT PRIMARY KEY,
    long_name TEXT UNIQUE,
    type TEXT,
    parent TEXT,
    FOREIGN KEY (type) REFERENCES tag_types(type),
    FOREIGN KEY (parent) REFERENCES tags(name));
  CREATE TABLE synonyms (synonym TEXT PRIMARY KEY, canonic TEXT,
    FOREIGN KEY (canonic) REFERENCES tags(name));"
  echo "$SQL" | sqlite3 "$MEDIA_DB" || log_error "$SQL"
  log_notice "Created tables in database $MEDIA_DB"

  # Insert initial data
  SQL="
  INSERT INTO tag_types (type) VALUES ('container');
  INSERT INTO tag_types (type) VALUES ('leaf');
  "
  echo "$SQL" | sqlite3 "$MEDIA_DB"

  log_notice "Database $MEDIA_DB is ready"
}
drop_database(){
  rm "$MEDIA_DB"
  log_notice "Dropped database $MEDIA_DB"
}

# Will search for a tag by name, or synonym.
# returns a csv listing "name, long_name, type, parent"
# That has to be parsed by the caller.
get_tag_data(){
  tag_name=$1
  long_name=$tag_name
  if [[ -n "$2" ]] ; then
    log_error "Unexpected argument '$2' . Quote tags when using get_tag.";
    exit 1;
  fi
  # Usually do a direct shortname match.
  # Fall back to synonym after that
  # If asked for long_name, return that first
  SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM tags WHERE tags.long_name='$tag_name';"
  result=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")

  # Otherwise, always truncate it to short name and look for that.ÃŸ
  tag_name=$(get_short_name "$tag_name")

  if [ -z "$result" ]; then
    SQL="SELECT name, long_name, type, parent FROM tags WHERE name='$tag_name';"
    result=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")
  fi

  # Join the tags to the synonyms table to find the result by synonym
  if [ -z "$result" ]; then
    log_debug "Looking for synonyms of '$tag_name'"
    SQL="SELECT tags.name, tags.long_name, tags.type, tags.parent FROM synonyms INNER JOIN tags ON synonyms.canonic = tags.name WHERE synonyms.synonym='$tag_name';"
    result=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")
    if [ -n "$result" ]; then
      log_info "Switched to using synonym for '$tag_name' "
    fi
  fi
  if [ -z "$result" ]; then
    log_info "Could not find an entry or synonym matching $tag_name"
  fi

  echo $result;
}

# Load tag data into an associative array for convenient access
# Usage: get_tag_info "Dog"
#        echo "${tag_info[name]}"
#        echo "${tag_info[long_name]}"
#        echo "${tag_info[type]}"
#        echo "${tag_info[parent]}"
get_tag_info() {
  local tag="$1"
  local csv_data=$(get_tag_data "$tag")

  if [[ -z "$csv_data" ]]; then
    log_debug "No tag info found for '$tag'"
    return 1
  fi

  # Declare global associative array (bash 4+)
  declare -gA tag_info

  IFS="${DB_DELIMITER}" read -r tag_info[name] tag_info[long_name] tag_info[type] tag_info[parent] <<< "$csv_data"
}

# Individual accessor functions for single-value lookups
# Getting the name of a tag you already know seems redundant,
# but all the accessors include synonym and longname collapsing
get_tag_name() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r name _ _ _ <<< "$tag_data"
  echo "$name"
}

get_long_name(){
  tag_data=$(get_tag_data "$1");
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -z "$long_name" ]] ; then
    log_error "failed to find long name for $1"
  fi
  echo $long_name;
}
get_short_name(){
  long_name="$1"
  local pipe_pattern='\|'
  # Get everything after the last pipe
  tag_name="${long_name##*|}"
  echo "$tag_name"
}

get_tag_type() {
  local tag_data=$(get_tag_data "$1")
  IFS="${DB_DELIMITER}" read -r _ _ type _ <<< "$tag_data"
  echo "$type"
}

# Helper function that sets global variables (alternative to Pattern 1)
# Usage: parse_tag_data "$(get_tag_data 'Dog')"
#        echo "$tag_name $long_name $type $parent"
# Note: Variables are GLOBAL (no local keyword) so available to caller
# Can also be used to unset these variables.
parse_tag_data() {
  local csv_data="$1"
  if [[ -z "$csv_data" ]]; then
    tag_name=""
    long_name=""
    type=""
    parent=""
    return 1
  fi
  # These variables are NOT local, so they're set in the caller's scope
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$csv_data"
}

# Check if a tag exists in the database, and create it if not
# usage: ensure_tag_exists tag_name [tag_type] [parent]
ensure_tag_exists(){
  local tag_name=$1
  local long_name=$tag_name
  local tag_type=${2:-leaf}  # Default to 'leaf' if no type is provided
  local parent=$3            # Optional parent tag

  if [[ -z "$tag_name" ]] ; then
    log_error "No tag name for $0"
    return 1
  fi

  # If it appears to be a '|' delimited heirarchical tagname, deal with that
  local pipe_pattern='\|'
  if [[ $long_name =~ $pipe_pattern ]] ; then
    tag_name="${long_name##*|}"  # Get everything after the last pipe
    parent="${long_name%|*}"   # Get everything before the last pipe (parent hierarchy)
  fi

  # Check if the tag exists.
  result=$(get_tag_data "$tag_name");

  # If the tag doesn't exist, create it
  if [ -z "$result" ]; then
    log_notice "Tag '$tag_name' does not exist. Creating it with type '$tag_type'..."
    # create the entry, then add the parent association after
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO tags (name, long_name, type) VALUES ('$tag_name', '$long_name', '$tag_type');
    "
    echo "$SQL" | sqlite3 "$MEDIA_DB" || log_error "$SQL"
  else
    log_debug "Tag '$tag_name' already exists."
  fi

  # If parent is provided and the tag exists but has no parent, update it.
  current_parent=$(get_parent "$tag_name");
  if [[ -n "$parent" && -z "$current_parent" ]]; then
    log_info "Tag '$tag_name' should have parent '$parent' . Ensuring parent exists first."
    ensure_tag_exists "$parent"
    # That process may have resolved a synonym, so re-resolve to get the canonic parent name
    parent=$(get_tag_name "$parent")
    log_info "Ensuring parentage of '$tag_name' is in place."
    set_parent "$tag_name" "$parent"
    update_long_name_to_match_parent "$tag_name"
  fi
  # log_info "Tag '$tag_name' exists"
}

update_long_name_to_match_parent(){
  # Note, we cannot change the long_name of a tag that has other children already referring to it
  # without a cascade effect, and it's prohibited by DB constraints.
  tag_name=$1
  tag_data=$(get_tag_data "$tag_name")
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ -z "$parent" ]] ; then
    log_debug "'$tag_name' has no parent. No update needed."
    return 0;
  fi
  parent_long_name=$(get_long_name "$parent")
  expected_long_name="${parent_long_name}|${tag_name}"
  if [[ "$long_name" != "$expected_long_name" ]] ; then
    log_notice "Updating long_name of '$tag_name' from '$long_name' to '$expected_long_name' ."
    SQL="
    PRAGMA foreign_keys = ON;
    UPDATE tags SET long_name = '$expected_long_name' WHERE name = '$tag_name';
    "
    echo "$SQL" | sqlite3 "$MEDIA_DB" || log_error "$SQL"
  else
    log_debug "Long name of '$tag_name' is already correct."
  fi
}

# Lookup by name or longname. $tag may be any shape.
# It's valid for a tag to have no parent/
get_parent(){
  tag=$1
  tag_data=$(get_tag_data "$tag")
  IFS="${DB_DELIMITER}" read -r tag_name long_name type parent <<< "$tag_data"
  if [[ ! -z "$parent" ]] ; then
    log_debug "Parent of '$tag_name' is '$parent' ."
  else
    log_debug "'$tag_name' has no parent in the DB yet."
  fi
  echo $parent;
}

# Set parent relationship using tag names as foreign keys
# Parameters can be name, long_name, or synonym - will be resolved to name
set_parent(){
  child_tag=$1
  parent_tag=$2
  log_notice "Setting parent of '$child_tag' to '$parent_tag'."

  # Resolve both to canonical names in case someone was using synonyms etc.
  parent_name=$(get_tag_name "$parent_tag")
  child_name=$(get_tag_name "$child_tag")

  if [[ -z "$child_name" ]]; then
    log_error "Cannot find name of tag tag '$child_tag'. The child tag must exist before it can have the parent set"
    return 1
  fi

  if [[ -z "$parent_name" ]]; then
    log_error "Cannot find name of parent tag '$parent_tag'. The parent tag must exist befor it is referenced."
    return 1
  fi

  SQL="
  PRAGMA foreign_keys = ON;
  UPDATE tags SET parent = '$parent_name' WHERE name = '$child_name';
  "
  echo "$SQL" | sqlite3 "$MEDIA_DB" || log_error "$SQL"
}

# usage:
# set_synonym canonic synonym
# Resolves canonic to tag name for foreign key relationship
set_synonym(){
  canonic=$1
  synonym=$2

  # Resolve to canonical tag name
  canonic_name=$(get_tag_name "$canonic")
  if [[ -z "$canonic_name" ]]; then
    log_error "No tag found for '$canonic'"
    return 1
  fi

  # Ensure the canonic tag exists before setting the synonym
  ensure_tag_exists "$canonic"

  # Check if the synonym already exists
  SQL="SELECT synonym FROM synonyms WHERE synonym='$synonym';"
  result=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")

  # If the synonym doesn't exist, create it
  if [ -z "$result" ]; then
    SQL="
    PRAGMA foreign_keys = ON;
    INSERT INTO synonyms (synonym, canonic) VALUES ('$synonym', '$canonic_name');
    ";
    echo "$SQL" | sqlite3 "$MEDIA_DB" || log_error "$SQL"
    log_notice "Added synonym '$synonym' for tag '$canonic_name'."
  else
    log_debug "Synonym '$synonym' already exists."
  fi
}

# List all tags in a column
# If a tag has synonyms, list each of them, indented, after the tag.
# If a tag has a parent, it will be displayed under its parent with indentation.
dump_tags(){
  # First, get all root tags (tags with no parent)
  SQL="SELECT name, long_name FROM tags WHERE parent IS NULL OR parent = '' ORDER BY name;"
  root_tags=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")

  # Process each root tag
  echo "$root_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name; do
    # Display the root tag
    if [ "$tag_type" = "container" ]; then
      printf "\033[90m%s\033[0m\n" "$tag_name [root]"
    else
      printf "%s\n" "$tag_name"
    fi

    # Display synonyms for this tag
    display_synonyms "$long_name" "  "

    # Display child tags recursively
    display_child_tags "$long_name" "|--"
  done
}

dump_db() {
  tables=( $(echo ".tables" | sqlite3 "$MEDIA_DB" ) )
  for table in "${tables[@]}"; do
    echo -e "\nTable: $table"
    SQL="SELECT * FROM $table;"
    echo "$SQL" | sqlite3 -column -header  "$MEDIA_DB"
  done
}

# Utility to check if the current scope has these variables set/
dump_tag_values(){
  echo "  name: $tag_name"
  echo "  long_name: $long_name"
  echo "  type: $type"
  echo "  parent: $parent"
}

# Update the tag hierarchy based on tag names with slashes.
# This is housekeeping, to deal with data thant may have been imported roughly
# Tags with delimiters in their names will have their parent set to the leftmost parts
# For example, "Location|Inside|Bedroom" will have a parent of "Location|Inside"
# The delimiter is conventiolnally "|" to conform with Adobe Bridge HeirarchicalSubject
# but may be expanded to "/" or ":" instead.
update_tag_hierarchy(){
  log_notice "Updating tag hierarchy..."
  DELIMITER="|";

  # Get all tags with slashes in their names
  SQL="SELECT name FROM tags WHERE name LIKE '%${DELIMITER}%';"
  tags_with_slashes=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")

  # Process each tag
  if [ -n "$tags_with_slashes" ]; then
    # First, ensure all parent tags exist
    echo "$tags_with_slashes" | while read -r tag_name; do
      parent=$(parse_parent_of "$tag_name")
      # Split the tag name by delimiter into array (portable for bash/zsh)
      local oldIFS="$IFS"
      IFS="${DELIMITER}"
      parts=($tag_name)
      IFS="$oldIFS"
      # If there's only one part, skip (no parent)
      if [ ${#parts[@]} -le 1 ]; then
        continue
      fi

      # Ensure all parent tags in the hierarchy exist
      current_path=""
      for ((i=0; i<${#parts[@]}-1; i++)); do
        if [ $i -eq 0 ]; then
          current_path="${parts[$i]}"
        else
          current_path="$current_path${DELIMITER}${parts[$i]}"
        fi

        # Ensure this parent tag exists as a container
        ensure_tag_exists "$current_path" "container"
      done
    done

    # Now set the parent for each tag
    # re-read the list to take into account any interim tags that may have been added.
    tags_with_slashes=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")
    echo "$tags_with_slashes" | while read -r tag_name; do
      # Split the tag name by delimiter into array (portable for bash/zsh)
      local oldIFS="$IFS"
      IFS="${DELIMITER}"
      parts=($tag_name)
      IFS="$oldIFS"

      # If there's only one part, skip (no parent)
      if [ ${#parts[@]} -le 1 ]; then
        continue
      fi

      # Determine the parent tag
      parent_tag=""
      if [ ${#parts[@]} -eq 2 ]; then
        # For tags with one slash (e.g., "Location|Inside"), the parent is the first part
        parent_tag="${parts[0]}"
      else
        # For tags with multiple slashes, build the parent path
        parent_tag=""
        for ((i=0; i<${#parts[@]}-1; i++)); do
          if [ $i -eq 0 ]; then
            parent_tag="${parts[$i]}"
          else
            parent_tag="$parent_tag${DELIMITER}${parts[$i]}"
          fi
        done
      fi

      set_parent "$tag_name" "$parent_tag"
    done

    log_notice "Tag hierarchy updated successfully."
  else
    log_notice "No tags with ${DELIMITER} delimiters found."
  fi

  # Display the updated hierarchy
  log_notice "Displaying updated tag hierarchy:"
  dump_tags
}

# chop the rightmost part of a path off.
# Basically identical to dirname?
parse_parent_of(){
  local tag_name="$1"
  # Split the tag name by slashes
  mapfile -d '/' -t parts < <(echo -n "$tag_name")

  # If there's only one part, skip (no parent)
  if [ ${#parts[@]} -le 1 ]; then
    return 0
  fi
  # For tags with multiple slashes, build the parent path
  parent_tag=""
  for ((i=0; i<${#parts[@]}-1; i++)); do
    if [ $i -eq 0 ]; then
      parent_tag="${parts[$i]}"
    else
      parent_tag="$parent_tag/${parts[$i]}"
    fi
  done
  echo $parent_tag
}

# Helper function to display synonyms for a tag
display_synonyms(){
  local tag="$1"
  local indent="$2"

  # Resolve to canonical name (canonic column stores names)
  local tag_name=$(get_tag_name "$tag")
  if [[ -z "$tag_name" ]]; then
    return 0
  fi

  # Get all synonyms for this tag
  SQL="SELECT synonym FROM synonyms WHERE canonic='$tag_name' ORDER BY synonym;"
  synonyms=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")

  # List each synonym indented
  if [ -n "$synonyms" ]; then
    echo "$synonyms" | while read -r synonym; do
      printf "${indent}AKA: %s\n" "$synonym"
    done
  fi
}

# Helper function to display child tags recursively
# Expects tag identifier (name, long_name, or synonym) - will be resolved to name
display_child_tags(){
  local parent_tag="$1"
  local indent="$2"

  # Resolve parent_tag to canonical name (parent column stores names)
  local parent_name=$(get_tag_name "$parent_tag")
  if [[ -z "$parent_name" ]]; then
    return 0
  fi

  # Get all child tags for this parent
  SQL="SELECT name, long_name, type FROM tags WHERE parent='$parent_name' ORDER BY name;"
  child_tags=$(echo "$SQL" | sqlite3 -separator "$DB_DELIMITER" "$MEDIA_DB")
  # Process each child tag
  if [ -n "$child_tags" ]; then
    echo "$child_tags" | while IFS="$DB_DELIMITER" read -r tag_name long_name tag_type; do
      # Display the child tag with indentation
      if [ "$tag_type" = "container" ]; then
        printf "${indent}\033[90m%s\033[0m\n" "$tag_name"
      else
        printf "${indent}%s\n" "$tag_name"
      fi

      # Display synonyms for this child tag
      display_synonyms "$long_name" "${indent}  "

      # Recursively display this child's children (pass name for FK lookup)
      display_child_tags "$tag_name" "${indent}${indent}"
    done
  fi
}

# Parallel file processing utility
# Processes all files recursively in the input arguments using parallel execution.
# Expects the caller to define a 'processFile' function and export any additional
# functions needed (e.g., export -f processWebpFile if processFile depends on it).
# Note: Feedback from sub-processes may get jumbled due to parallel execution.
# Note: Uses BSD xargs syntax (macOS) - -0: null-separated, -P: parallel, -I: replace
parallalProcessFiles() {
    export -f processFile;
    find "$@" -type f -print0 | xargs -0 -P 4 -I {} bash -c 'processFile "$1"' _ "{}"
}

verifyDatabase() {
  log_notice "MEDIA_DB=$MEDIA_DB"
  # Require sqlite3 or die
  if ! command -v sqlite3 >/dev/null 2>&1; then
    log_error "sqlite3 is required"
    exit 1
  fi

  # Check if the database file exists and is a valid SQLite database
  if [ ! -f "$MEDIA_DB" ]; then
    log_notice "Database file $MEDIA_DB does not exist. Creating it..."
    create_database;
  else
    # Check if it's a valid SQLite database by trying to run a simple query
    if ! echo ".tables" | sqlite3 "$MEDIA_DB" &>/dev/null; then
      log_notice "Database file $MEDIA_DB exists but appears to be invalid. Recreating it..."
      drop_database;
      create_database;
    else
      log_notice "Database file $MEDIA_DB exists and is valid."
    fi
  fi
}

verifyDatabase
